<body bgcolor="black" style="margin: 0">
  <script src="math.js"></script>
  <script src="webgl.js"></script>
  <script src="scene.js"></script>
  <script type="module" src="mediapipe.js"></script>
  <script>
    // RENDER A LARGE TEXT MESSAGE IN A LINEFONT

    let throttle = (callback, wait) => {
      let timeoutId = null;
      return (...args) => {
        if (timeoutId !== null) return;

        callback(...args);
        timeoutId = setTimeout(() => {
          timeoutId = null;
        }, wait);
      };
    };

    function rotateVectorY(v, ang) {
      let m = [c(ang), 0, -s(ang), 0, 1, 0, s(ang), 0, c(ang)];
      return [
        v[0] * m[0] + v[1] * m[1] + v[2] * m[2],
        v[0] * m[3] + v[1] * m[4] + v[2] * m[5],
        v[0] * m[6] + v[1] * m[7] + v[2] * m[8]
      ];
    }

    function mxv3(m, v) {
      return [
        v[0] * m[0] + v[1] * m[1] + v[2] * m[2],
        v[0] * m[4] + v[1] * m[5] + v[2] * m[6],
        v[0] * m[8] + v[1] * m[9] + v[2] * m[10]
      ];
    }
    function Scene() {
      let createPathsMesh = (lineWidth, paths) => {
        let vertices = [];
        let addVertex = (pos) => vertices.push(pos, [0, 0, 1]);
        for (let n = 0; n < paths.length; n++) {
          let path = paths[n];
          for (let i = 0; i < path.length - 1; i++) {
            let b = path[i];
            let c = path[i + 1];
            let a = i > 0 ? path[i - 1] : add(b, subtract(b, c));
            let da = normalize(subtract(b, a));
            let dc = normalize(subtract(c, b));
            let db = normalize(add(da, dc));
            let s = dot(da, db);
            da = resize(da, lineWidth / 2);
            dc = resize(dc, lineWidth / 2);
            db = resize(db, lineWidth / 2);
            let ea = [-da[1], da[0], 0];
            let ec = [-dc[1], dc[0], 0];
            let eb = [-db[1] / s, db[0] / s, 0];
            if (i == 0) b = subtract(b, da);
            if (dot(da, dc) < 0) {
              if (n > 0 && i == 0) addVertex(subtract(b, ea));
              addVertex(subtract(b, ea));
              addVertex(add(b, ea));
              addVertex(subtract(b, ec));
              addVertex(add(b, ec));
            } else {
              if (n > 0 && i == 0) addVertex(subtract(b, eb));
              addVertex(subtract(b, eb));
              addVertex(add(b, eb));
            }
            if (i == path.length - 2) {
              addVertex(subtract(add(c, dc), ec));
              addVertex(add(add(c, dc), ec));
            }
            if (n < paths.length - 1 && i == path.length - 2)
              addVertex(add(add(c, dc), ec));
          }
        }
        return {
          triangle_strip: true,
          data: new Float32Array(vertices.flat())
        };
      };

      let createTextMesh = (text) => {
        let myPaths = [],
          lines = text.split("\n"),
          c;
        for (let row = 0; row < lines.length; row++)
          for (let col = 0; col < lines[row].length; col++)
            if ((c = lines[row].charCodeAt(col) & 127) > 32) {
              let x = 0.019 * col,
                y = -0.0375 * row;
              let paths = linefont[c - 32].paths;
              for (let i = 0; i < paths.length; i++) {
                let myPath = [],
                  path = paths[i];
                for (let j = 0; j < path.length; j++) {
                  let p = path[j];
                  myPath.push([x + p[0] / 4000, y - p[1] / 4000, 0]);
                }
                myPaths.push(myPath);
              }
            }

        console.log(myPaths);
        return createPathsMesh(0.0025, myPaths);
      };

      let pathMeshes = [];
      let currentMesh = [];

      let spinY = 0;
      let spinX = 0;
      let isShifting = false;

      mouse.down.push(() => {
        currentMesh.push([]);
      });
      mouse.drag.push(
        throttle((x, y, e) => {
          if (e.shiftKey) return;
          let i = currentMesh.length - 1;
          let vec = [mouse.x / 10, mouse.y / 10, 0];
          vec = mxv3(turnY(spinY), vec);
          vec = mxv3(turnX(spinX), vec);
          currentMesh[i].push(vec);
        }, 50)
      );

      mouse.drag.push((x, y, e) => {
        if (!e.shiftKey) return;
        spinY += x;
        spinX -= y;
      });

      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" && currentMesh.length > 0) {
          const mesh = createPathsMesh(0.0025, currentMesh);
          pathMeshes.push(mesh);
          currentMesh = [];
          if (this.penRadius < penThreshold) currentMesh.push([]);
        }
        if (e.code === "ShiftLeft") {
          isShifting = true;
        }
      });

      document.addEventListener("keyup", (e) => {
        console.log(e.code);
        if (e.code === "ShiftLeft") {
          isShifting = false;
        }
      });

      pathMeshes.push(
        createTextMesh(`\
Now is the time
for all good men
to come to the aid
of their party.`)
      );

      this.vertexShader = Shader.defaultVertexShader;
      this.fragmentShader = Shader.defaultFragmentShader;

      autodraw = false;

      this.lastPenRadius = 999;
      this.penRadius = 999;
      this.penPos;
      this.lastPenPos;

      const penThreshold = 0.01;

      let M = new Matrix();

      let throttledDrawMesh = throttle((x, y, e) => {
        if (e?.shiftKey) return;
        let i = currentMesh.length - 1;
        let vec = [mouse.x / 5, mouse.y / 5, 0];
        vec = mxv3(turnY(spinY), vec);
        vec = mxv3(turnX(spinX), vec);
        currentMesh[i].push(vec);
      }, 50);

      let draw = (mesh, matrix, color) => {
        let m = mxm(perspective(0, 0, -0.5), matrix ?? M.get());
        setUniform("Matrix4fv", "uMF", false, m);
        setUniform("Matrix4fv", "uMI", false, inverse(m));
        setUniform("3fv", "uColor", color ?? [1, 1, 1]);
        drawMesh(mesh);
        return this;
      };

      this.update = () => {
        let time = Date.now() / 1000;
        let t = time / 2;

        if (
          this.lastPenRadius > penThreshold &&
          this.penRadius < penThreshold
        ) {
          currentMesh.push([]);
        }
        if (
          this.lastPenRadius < penThreshold * 50 &&
          this.penRadius > penThreshold * 50 &&
          currentMesh.length > 0
        ) {
          const mesh = createPathsMesh(0.0025, currentMesh);
          pathMeshes.push(mesh);
          currentMesh = [];
        }

        if (this.penRadius < penThreshold) {
          mouse.x = 1 - this.penPos.x * 2;
          mouse.y = 1 - this.penPos.y * 2;
          throttledDrawMesh();
        }
        if (isShifting) {
          dx = this.penPos.x - this.lastPenPos.x;
          dy = this.penPos.y - this.lastPenPos.y;

          spinY -= dx * 2;
          spinX += dy * 2;
        }

        this.lastPenRadius = this.penRadius;
        this.lastPenPos = this.penPos;

        let meshesToDraw = [...pathMeshes];
        if (currentMesh.length > 0) {
          const mesh = createPathsMesh(0.0025, currentMesh);
          meshesToDraw.push(mesh);
        } else {
          meshesToDraw.push(null);
        }

        for (let i = 0; i < meshesToDraw.length; i++) {
          const mesh = meshesToDraw[meshesToDraw.length - 1 - i]; // reverse ordering
          const col = Math.max(0, (meshesToDraw.length - i) / 4);
          if (!mesh) continue;

          draw(
            mesh,
            mxm(turnX(spinX), mxm(turnY(spinY), mxm(move(0, 0, -i), scale(5)))),
            [col, col, col]
          );
        }
      };
    }
  </script>
  <video
    id="webcam"
    style="position: absolute"
    autoplay
    playsinline
    hidden
  ></video>
  <div
    style="
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    "
  >
    <canvas id="canvas" width="800" height="800"></canvas>
    <canvas
      id="mediapipe_canvas"
      height="800"
      style="position: absolute; top: 0; transform: scaleX(-1)"
    ></canvas>
    <button id="webcamButton">Enable hand controls</button>
    <p style="color: white; text-align: center">
      Pinch with pointer, middle and thumb to draw<br /><br />Spread fingers at
      camera to push drawing back<br /><br />Hold shift to move camera<br />
    </p>
  </div>
</body>
